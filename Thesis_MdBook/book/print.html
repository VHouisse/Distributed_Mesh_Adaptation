<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Distributed Mesh Adapatation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "rust";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Distributed Mesh Adapatation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="1-contexte-général-et-motivations"><a class="header" href="#1-contexte-général-et-motivations">1. Contexte Général et Motivations</a></h1>
<h2 id="11-le-défi-de-la-simulation-numérique-et-lessence-de-ladaptation-de-maillage"><a class="header" href="#11-le-défi-de-la-simulation-numérique-et-lessence-de-ladaptation-de-maillage">1.1 Le défi de la simulation numérique et l’essence de l’adaptation de maillage</a></h2>
<p>Dans le domaine de l’ingénierie et de la science, la modélisation et la simulation numérique jouent un rôle prépondérant pour comprendre et prédire le comportement de phénomènes physiques complexes. Que ce soit pour simuler les écoulements d’air autour d’une aile d’avion, la propagation de la chaleur dans un réacteur, ou la déformation de structures sous contrainte, atteindre une haute-fidélité dans ces simulations est un défi fondamental.</p>
<p>Résoudre numériquement les équations qui régissent ces phénomènes complexes impose une discrétisation préalable de l’espace et du temps. Pour cela, les maillages sont fondamentaux car ils permettent de décomposer la géométrie complexe induite par le problème en un ensemble fini d’éléments. Cette discrétisation, nécessaire, permet d’approximer des grandeurs physiques et donc de résoudre les équations sous jacente au problème de manière computationnelle.</p>
<p>Bien que les maillages soient essentiels, leur conception statique révèle certaines limites face à la compléxité des phénomènes physiques, notamment dans l’étude de la dynamique des fluides. Par exemple, capturer l’ensemble de l’information issue des écoulements turbulents avec un maillage statique est presque impossible. En effet, ces phénomènes se caractérisent par des gradients physiques très intenses et des structures de mouvement très complexes dans des zones très spécifiques du domaine (couche limite, sillage …).</p>
<p>L’approche d’un maillage statique et isotrope n’est donc pas optimale; il risque d’être insuffisamment raffiné là où une résolution très précise est cruciale et trop dense dans des zones moins critiques de l’écoulement. En plus de la perte d’information, ce déséquilibre entraine une surchage computationnelle injustifiée dans les régions où une moindre précision serait suffisante.</p>
<p>Pour surmonter ces défis et optimiser l’efficatité des simulations numériques haute-fidélité, l’adaptation de maillage anisotrope est primordiale. Cette approche dynamique permet un ajustement intelligent de la densité et de l’orientation des éléments du maillage en fonction des caractéristiques de la solution et des erreurs d’approximations commises. L’anisotropie permet d’affiner la résolution en alignant la forme des éléments du maillage avec les directions des phénomènes physiques prédominants. En concentrant précisément les ressources de calcul là où elles sont nécessaires et en les étirant ailleurs, elle maximise la précision et minimise les coûts.</p>
<p>Atteindre cette haute fidélité à l’échelle des applications industrielles modernes tel que celles de l’industrie de l’aéronautique exige de recourrir au calcul massivement parallèle. En effet, le volume de données et la compléxité des calculs deviennent colossaux, un maillage typique pour ce genre simulation peut compter des dizaines, voire des centaines de millions d’éléments.</p>
<p>Garantir l’éfficatité des calculs sur un tel volume de données ne peut se faire que via l’exploitation du calcul parallèle. Cela implique de distribuer le maillage et les opérations de calcul intrinsèques, tel que les opérations d’adaptation, sur des milliers de coeurs de calcul différents. Cette dimension parallèle induit une surcouche de complexité ; il faut garantir une répartition équitable du temps de calcul et une communication efficace et minime entre chaque processeur ainsi que la conservation de la cohérence des calculs. C’est dans ce contexte de haute performance que les solutions d’adaptation de maillage doivent s’inscrire pour être réellement utile aux applications industrielles.</p>
<h2 id="12-contexte-industriel-et-objectifs"><a class="header" href="#12-contexte-industriel-et-objectifs">1.2 Contexte Industriel et Objectifs</a></h2>
<p>Le présent travail de thèse s’inscrit au sein d’une collaboration entre Airbus et le Cerfacs, dans le but de répondre à des besoins industiels concrets en dynamique des fluides numérique par le biais de la recherche appliquée. Au coeur de cette initiative se trouve CODA (Code ONERA DLR AIRBUS ), un outil de simulation numérique pour la dynamique des fluides massivement parallèle gérant des calculs de très grande envergure.
L’objectif principal de cette thèse est de développer un cadre d’adaptation de maillage anisotrope parallèle pour CODA. Le but ultime est de réduire les délais de conception et d’élargir le champ d’exploration de design des aviosn dans les bureaux d’études d’Airbus.</p>
<p>Pour y parvenir, une part essentielle de la thèse consistera à identifier et à implémenter des métriques anisotropes adaptées à la capture de phénomènes clés comme les couches limites et les chocs transsoniques, ainsi que des métriques “goal-based” exploitant la sensibilité adjointe. La mise en œuvre de ce workflow d’adaptation distribuée débutera par une version en ligne de commande, puis évoluera vers un couplage direct avec le module FSDM de CODA via l’API kalpaTARU C. L’efficacité du workflow sera validée à travers des applications concrètes sur des configurations d’avions représentatives (LAGOON, DPW).</p>
<h2 id="13-feuille-de-route"><a class="header" href="#13-feuille-de-route">1.3 Feuille de Route</a></h2>
<p>Ce MdBook a pour vocation de présenter l’intégralité des avancées et des résultats obtenus au cours de ma thèse de doctorat. Au fil des chapitres, il retracera l’évolution continue de ma thèse, de mes explorations intiailes aux résultats les plus récents. Chaque section abordera un aspect fondamental de ma recherche : l’acquisition de connaissances théoriques relatives à l’adaptation de maillage anisotropique, l’environnement de développement et les outils utilisés ainsi que l’ensemble de mes contributions scientifiques. L’objectif est de fournir une vision claire et structurée de l’état d’avancement de ma recherche, des défis rencontrés et des solutions développées tout au long de ces trois années, offrant ainsi un aperçu complet de mon parcours doctoral.</p>
<p><br><br><br></p>
<div style="display: flex; justify-content: space-between; align-items: flex-start;">
    <img src="Intro/../images/Airbus.png" alt="Image à gauche" style="width: 30%;">
    <img src="Intro/../images//CERFACS.png" alt="Image à droite" style="width: 30%;">
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theoritical-foundations"><a class="header" href="#theoritical-foundations">Theoritical Foundations</a></h1>
<p>Pour appréhender pleinement les travaux présentés dans ce document, une bonne compréhension des concepts fondamentaux liés à l’adaptation de maillage dans sa généralité est essentielle. Cette section détaillera donc:</p>
<ul>
<li>
<p><a href="Theoritical_Foundations/./Metrics.html">Metrics</a></p>
</li>
<li>
<p><a href="Theoritical_Foundations/./Mesh_Adaptation.html">Mesh Adaptation</a></p>
</li>
<li>
<p><a href="Theoritical_Foundations/./Parallel_Computing.html">Parallel Computing</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metric"><a class="header" href="#metric">Metric</a></h1>
<h3 id="211-definition"><a class="header" href="#211-definition">2.1.1 Definition:</a></h3>
<p>A metric tensor \( \mathcal{M} \in \mathbb{R}^{n} \) is an \(n \times n \) symmetric definite positive matrix.<br />
\( \mathcal{M} \) is always diagonalizable and can be decomposed as \( \mathcal{M}= {^T}\mathcal{R} \Delta \mathcal{R} \) where \(\mathcal{R}\) and \(\Delta\) are the eigenvectors and the eigenvalues matrices of \(\mathcal{M}\), respectively.</p>
<p>From this definition, it follows up that the scalar product of two vectors in \(  \mathbb{R}^n \)
can defined related to a metric \(  \mathcal{M} \) as</p>
<p>\[  &lt;\textbf{u},\textbf{v}&gt;_{\mathcal{M}} = &lt;\textbf{u},\mathcal{M}\textbf{v} &gt; = {^t}\textbf{u}\mathcal{M}\textbf{v}\]</p>
<p>Under this notion, the Euclidean norm of a vector \(  \textbf{u}  \text{ in } \mathbb{R}^n\) according to \(  \mathcal{M}\) is defined as</p>
<p>\[ \left| \textbf{u} \right| = \sqrt{&lt;\textbf{u},\textbf{u} &gt;_{\mathcal{M}} } = \sqrt{  \textbf{u}^{t} \mathcal{M} \textbf{u} } \]</p>
<p>This formula allows us to measure the length of a vector \(\textbf{u}\) with repsect to a certain metric \( \mathcal{M}\).</p>
<p>A metric \(\mathcal{M}\) can be geometrically represented by its associated unit ball, defined by</p>
<p>\( \xi _{M} ={ p | \sqrt{ \textbf{op}^{t} \mathcal{M} \textbf{op} }=1|  } \)</p>
<p><br><br></p>
<figure style="text-align: center;">
  <img src="Theoritical_Foundations/../images/Metric_1.png" alt="Anisotropic metric tensor" width="90%">
  <figcaption>Figure 1: Metric Unit Ball </figcaption>
</figure>
<h3 id="212-definition"><a class="header" href="#212-definition">2.1.2 Definition</a></h3>
<p>An Euclidean metric space is a vector space supplied with a certain scalar product \(&lt;.,.&gt;_{\mathcal{M}}\) defined by a metric tensor \(\mathcal{M}\). We denote it \( (\mathbb{R}^n, \mathcal{M} ) \).<br />
The distance between two point \(\textbf{p}\) and \(\textbf{q}\) is given by:</p>
<p>\[  d_{ \mathcal{M} }( \textbf{p},\textbf{q} ) = \sqrt{  \textbf{pq}^{t} \mathcal{M} \textbf{pq} }  \]</p>
<p>Finaly the lenght of a segment \( \textbf{pq} \) is the distance between its extremities</p>
<p>\(    \mathcal{L}_ { \mathcal{M} } ( \textbf{pq} ) = d_{ \mathcal{M} } ( \textbf{p},\textbf{q} )  \).</p>
<h3 id="213-remark"><a class="header" href="#213-remark">2.1.3 Remark</a></h3>
<p>If the Metric defining the scalar product is the identity matrix, \( \mathcal{M} = \mathbb{I} _{n} \) then we get the standart Euclidean space \( ( \mathbb{R}^n , \mathbb{I} _{n} )\) supplpied with the natural dot product \(\).</p>
<p><br><br></p>
<p>It is then possible to define volumes and angles in an Euclidean metric space. Let K be a bounded subset of \( \mathbb{R}^n \), the volume of an element K in metric \( \mathcal{M} \) is:</p>
<p>\( |K| _{ \mathcal{M} }  = \int _{K} \sqrt{det( \mathcal{M} )} |K| _{ \mathbb{I} _{n}} \)</p>
<p>The angle between two vectors \(  \textbf{u} \) and \( \textbf{v} \) is define by the unique real \( \theta \in [ 0 , \pi ] \) such that</p>
<p>\[ cos(\theta) = \frac{ &lt;\textbf{u} , \textbf{v} &gt; _{\mathcal{M}} }{||\textbf{u}|| _{\mathcal{M}}  ||\textbf{v}|| _{\mathcal{M}}}\]</p>
<h3 id="214-definition"><a class="header" href="#214-definition">2.1.4 Definition</a></h3>
<p>A \( \textit{Riemmanian}\) metric space is a continuous manifold \( \Omega \subset \mathbb{R}^n  \) supplied with a smooth metric \( \mathcal{M}(.) \). We denote it by \(  \mathcal{M}(\textbf{x}) _{x \in \Omega} \).</p>
<p>Contrary to the Euclidean metric space case, the distance between two points, i.e., the shortest path, is no more the straight line but it is given by a geodesic. Nevertheless, in the context of mesh generation or mesh adaptation, we rae not interested in the distance between two points but in the lenght of a path fiven by an edge of the mesh.
More precisely, in a Riemmanian metric space \( \mathcal{M}(\textbf{x}) _{x \in \Omega} \), the length of an edge \( \textbf{pq} \) is calculated using the straight line parametrization \( \gamma(t) = \textbf{p} + t \textbf{pq}, \ t \in [0,1]  \) :</p>
<p>\[  \mathcal{L}_ { \mathcal{M} } ( \textbf{pq} ) =  \int_{0}^{1} || \gamma (t) || \ dt = \int_{0}^{1} \sqrt{\textbf{pq}^t \mathcal{M}(\textbf{p}+t\textbf{pq})\textbf{pq}} \ dt \]</p>
<figure style="text-align: center;">
  <img src="Theoritical_Foundations/../images/Riemmanian.png" alt="Isovalues of the fonction f(x) = lm(ox) for different Spaces" width="90%">
  <figcaption> \( \textbf{Figure 2:} \)  Isovalues of the fonction \( f(x) = \mathcal{L}_m (ox) \) for different spaces.<br> 
  Left, the standard Euclidean Space \(([-1,1]*[-1,1], \mathbb{I} _{2} ) \)<br>
  Midlle, an Euclidean metric Space \(([-1,1]*[-1,1], \mathcal{M} ) \)<br>
  Right, a Riemmanian Metric Space \( (\mathcal{M}(x))_{x \in [-1,1]^2}\) </figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-adaptation"><a class="header" href="#mesh-adaptation">Mesh Adaptation</a></h1>
<p>The core advantage of using metric tensors in mesh generation and adaptation lies in their ability to impose specific directional stretching on mesh elements. This allows us to briefly detail our approach to anisotropic mesh generation: by defining a mesh size in each direction at every point of the domain using metric tensors, it’s then possible to generate a uniform unit mesh, thus specifying sizes directionally.</p>
<p>More precisely, let \(\mathcal{M}(x)_{x \in \Omega }\) be a Riemmanian metric space. In three dimensions, the objective is to generate a mesh    \(\mathcal{H} \) for which each edge lenght is unit in the associated metric and each element is regular :</p>
<p>\[   \forall \textbf{e} \in \mathcal{H} , \mathcal{L}_ \mathcal{M}(\textbf{e})= 1  \text{      and       } \forall K \in \mathcal{H}, |K|_{\mathcal{M}} = \frac{\sqrt{2}}{12} \]</p>
<p>As a regular elements can not fill the entire domain \( \Omega \), the mesh generator can only create quasi-uniform mesh, i.e. the mesh elements are almost unit in the Riemmanian space. To quantify the fap to unity, differents tools can be used, for example, an element_quality function :
\[ Q_\mathcal{M}\] \(\)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallel-computing"><a class="header" href="#parallel-computing">Parallel Computing</a></h1>
<p>Scaling
Coeurs
Etc …</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="work-environnement"><a class="header" href="#work-environnement">Work Environnement</a></h1>
<p>This section presents the essential tools and the development environment employed throughout this thesis.</p>
<ul>
<li><a href="Work_Environnement/./Tucanos.html">Tucanos</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tucanos"><a class="header" href="#tucanos">Tucanos</a></h1>
<p>Tucanos is a 2D and 3D anisotropic mesh adaptation library. It is based on the principles described in “Four-Dimensional Anisotropic Mesh Adaptation for Spacetime Numerical Simulations” by Philip Claude Caplan.</p>
<p>The project is enterily coded in Rust, but it also has a Python interface.</p>
<p>You can find more information and the source code for Tucanos on its official GitHub repository: <a href="https://github.com/tucanos/tucanos">https://github.com/tucanos/tucanos</a>.</p>
<br>
<center>
<img src="Work_Environnement/../images/Tucanos.png" alt="Logo Tucanos" width="40%">
<center><div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<h3 id="lenvironnement-hpc"><a class="header" href="#lenvironnement-hpc">L’environnement HPC</a></h3>
<p>Mes travaux de thèse sont ancrés au sein d’un cluster de calcul haute performantce (HPC). Cet environnement possède une architecture robuste conçue pour répondre aux exigences des calculs massifs liés aux activités d’ingénierie AIRBUS. L’environnement est composé de noeuds de calcul optimisé en terme de puissance et de mémoire.
La machine utilisée est composée de deux types de noeuds calcul :</p>
<br>
<div class="table-wrapper"><table><thead><tr><th>Caractéristiques \ Types</th><th>Type 1</th><th>Type 2</th></tr></thead><tbody>
<tr><td>Processeurs</td><td>2 Xeon-G 6142</td><td>2 Xeon-G 6142</td></tr>
<tr><td>Coeurs physiques par processeurs</td><td>16 (HT)</td><td>16 (HT)</td></tr>
<tr><td>Base Clock Speed</td><td>1.6 Ghz</td><td>1.6 Ghz</td></tr>
<tr><td>Memory Speed</td><td>2666 Mhz</td><td>2666 Mhz</td></tr>
<tr><td>RAM</td><td>96GB</td><td>384 GB</td></tr>
<tr><td>Stockage local</td><td>1 TB HDD</td><td>3.8 TB SSD</td></tr>
</tbody></table>
</div><br>
<p>La machine comprend 110 noeuds de Type 1 et 16 de Type2.</p>
<p>L’ensemble du cluster est géré par LSF (Load Sharing Facility) qui alloue dynamiquement des ressources critiques en fonction des requêtes soumises.</p>
<h3 id="mdbook--outil-de-documentation-et-de-suivi-de-thèse"><a class="header" href="#mdbook--outil-de-documentation-et-de-suivi-de-thèse">MdBook : Outil de Documentation et de Suivi de Thèse</a></h3>
<p>Ce document lui-même est généré à l’aide de <strong>MdBook</strong>, un outil de publication de livres statiques basé sur Markdown.
MdBook offre plusieurs fonctionnalités clés qui sont particulièrement pertinentes pour la documentation d’une thèse en calcul scientifique :</p>
<ul>
<li>
<p>Sa syntaxe Markdown est légère et aide à se concentrer sur le contenu.</p>
</li>
<li>
<p>Il inclut un support de recherche intégré.</p>
</li>
<li>
<p>La coloration syntaxique pour les blocs de code est prise en charge pour de nombreux langages différents.</p>
</li>
<li>
<p>Des fichiers de thème permettent de personnaliser le formatage de la sortie.</p>
</li>
<li>
<p>Les préprocesseurs peuvent fournir des extensions pour une syntaxe personnalisée et modifier le contenu.</p>
</li>
<li>
<p>Les backends peuvent rendre la sortie dans plusieurs formats.</p>
</li>
<li>
<p>Écrit en Rust, MdBook est conçu pour la vitesse, la sécurité et la simplicité.</p>
</li>
<li>
<p>Il permet également le test automatisé des exemples de code Rust qui sera très utile pour certaines fonctionnalités implémentées dans Tucanos.</p>
</li>
</ul>
<p><strong>MdBook</strong> : <a href="https://rust-lang.github.io/mdBook/index.html">https://rust-lang.github.io/mdBook/index.html</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encadrement"><a class="header" href="#encadrement">Encadrement</a></h1>
<p>Le succès de ce projet de thèse repose sur un encadrement solide et multidisciplinaire, bénéficiant de l’expertise combinée d’Airbus et du Centre Européen de recherche et de formation en Calcul Scientifque (CERFACS) :</p>
<ul>
<li>
<p><strong>Laraufie Romain</strong> : Encadrant principal AIRBUS</p>
</li>
<li>
<p><strong>Xavier Garnaud</strong> : Encadrant AIRBUS</p>
</li>
<li>
<p><strong>Jerome Robert</strong> : Encadrant AIRBUS</p>
</li>
<li>
<p><strong>Jean-Christophe Jouhaud</strong> : Directeur de thèse et représentant CERFACS</p>
</li>
<li>
<p><strong>Michael Rudgyard</strong>: Encadrant CERFACS</p>
</li>
<li>
<p><strong>Jens-Dominik Mueller</strong> : Encadrant CERFACS</p>
</li>
</ul>
<p><br><br><br></p>
<div style="display: flex; justify-content: space-between; align-items: flex-start;">
    <img src="Work_Environnement/../images/Airbus.png" alt="Image à gauche" style="width: 30%;">
    <img src="Work_Environnement/../images//CERFACS.png" alt="Image à droite" style="width: 30%;">
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organisation-des-travaux-de-recherche"><a class="header" href="#organisation-des-travaux-de-recherche">Organisation des travaux de recherche</a></h1>
<ul>
<li>
<p><strong>[M1-M6]</strong> Immersion dans le logiciel CODA et son environnement, incluant l’environnement de développement, les outils de pré/post-traitement et l’environnement HPC  Td’Airbus. L’objectif est d’apprendre et de se former sur le logiciel CODA et de mettre en place le calcul de cas tests pertinents.</p>
</li>
<li>
<p><strong>[M1-M6]</strong>  Réalisation d’une revue de littérature sur les métriques de maillage existantes pour les applications aéronautiques, la résolution près des parois, les écoulements turbulents, les écoulements transsoniques avec chocs, et les méthodes basées sur l’objectif utilisant la sensibilité adjointe.</p>
</li>
<li>
<p><strong>[M4-M17]</strong>  L’implémentation du support de la métrique anisotrope sera réalisée dans kalpaTARU. Cela inclura l’extension du support existant de la métrique scalaire aux champs de métriques tensoriels, l’adaptation de l’interpolation de métrique distribuée existante aux champs tensoriels, et l’implémentation de critères de seuillage pour les champs tensoriels. Les tests seront effectués en utilisant l’infrastructure d’adaptation de maillage autonome existante.</p>
</li>
<li>
<p><strong>[M7-M11]</strong> Apprentissage et formation sur l’utilisation et le développement de Tucanos afin de réaliser les développements nécessaires pour supporter l’adaptation de maillage distribuée. Cela implique le gel de l’adaptation des faces des processeurs, l’information de tag pour la gestion des indices globaux-locaux, et l’API C/Rust pour la nouvelle fonctionnalité créée.</p>
</li>
<li>
<p><strong>[M11-M17]</strong> En Phase 1, Tucanos-kalpaTARU sera couplé via une interface en ligne de commande (CLI). Le principal travail de développement consistera à implémenter un plugin d’E/S pour les maillages CODA basé sur le plugin de maillage AVBP existant. La validation sera effectuée (adaptation de maillage statique) sur des maillages CODA simples avec des champs de métriques prescrits dans des fichiers HDF5.</p>
</li>
<li>
<p><strong>[M17-M24]</strong> En Phase 2, nous réaliserons le couplage de la structure de données FSDM en utilisant l’interface C-API de Tucanos-kalpaTARU. Les tests et la validation seront effectués sur des cas tests avec diverses métriques prescrites implémentées dans CODA.</p>
</li>
<li>
<p><strong>[M24-M30]</strong>  Les tests et la validation seront réalisés sur un cas test de production, à savoir la configuration de train d’atterrissage LAGOON et les configurations de Drag Prediction Workshop (DPW).</p>
</li>
<li>
<p><strong>[M30-M36]</strong>  Réalisation des tâches de rédaction de thèse et communication des publications pour satisfaire aux exigences du doctorat.</p>
</li>
</ul>
<p><br><br><br></p>
<div style="display: flex; justify-content: space-between; align-items: flex-start;">
    <img src="Work_Environnement/../images/Airbus.png" alt="Image à gauche" style="width: 30%;">
    <img src="Work_Environnement/../images//CERFACS.png" alt="Image à droite" style="width: 30%;">
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-explorations--contribution"><a class="header" href="#first-explorations--contribution">First Explorations &amp; Contribution</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partitionners"><a class="header" href="#partitionners">Partitionners</a></h1>
<p>Comme nous l’avons vu, la quantité de données induites par la résolution des équations de la CFD ainsi que la recherche de calcul de haute performance nous pousse à utiliser plusieurs unité de calcul. Pour cela il est impératif de partitionner le maillage sous-jacent au domaine de travail. Partitionner permet de diviser le domaine en autant de sous-domaines qu’il y a de coeurs disponibles, décomposant le problème initial en N sous-problèmes.</p>
<p>Un bon partitionnement repose sur trois critères essentiels :</p>
<p>Reduction des interdépendances : Minimiser les arêtes ou faces partagées entre les sous-domaines afin de limiter les communications coûteuses entre les unités de calcul.</p>
<p>Preservation de la qualité : Assurer que la division ne dégrade pas la qualité des sous-maillages individuels</p>
<p>Equilibrage de charge : Distribuer équitablement la charge de travail computationnel entre tous les processeurs afin d’eviter les goulots d’étranglement et maximiser la performance parallèle (CF Load balancing)</p>
<h3 id="partitionnement-pour-le-remaillage--le-défi-des-interfaces"><a class="header" href="#partitionnement-pour-le-remaillage--le-défi-des-interfaces">Partitionnement pour le Remaillage : Le Défi des Interfaces</a></h3>
<p>Dans le cadre du remaillage, la gestion des interfaces entre les partitions est un défi majeur, car ces frontières doivent être adaptées sans compromettre la continuité du maillage global ni l’efficacité parallèle. Deux approches principales peuvent être distinguées pour adresser ce problème</p>
<h4 id="two-step-process-"><a class="header" href="#two-step-process-">Two-Step process :</a></h4>
<p>Cette méthode débute par un premier partitionnement du maillage. Les interfaces de ces partitions initiales sont alors “gelées”, permettant à chaque processeur de remailler son sous-domaine interne de manière indépendante. Une fois cette première phase d’adaptation locale achevée, un second partitionnement est effectué sur l’ensemble du domaine, mais de manière à ce que les interfaces du premier partitionnement (celles qui étaient gelées) ne partagent aucun élément en commun avec les nouvelles interfaces du deuxième partitionnement. Cette stratégie garantit que la totalité du domaine, y compris les zones d’interface initialement gelées, soit effectivement remaillée, assurant ainsi une adaptation complète.</p>
<center>
<img src="Contributions/../images/Two_Step_Process.png" alt="Logo Tucanos" width="100%">
</center>
<br>
<h4 id="hierarchical-interface-freezing-method-"><a class="header" href="#hierarchical-interface-freezing-method-">Hierarchical Interface Freezing Method :</a></h4>
<p>Cette seconde approche est également basée sur le gel des interfaces, mais de manière itérative et hiérarchique. Le domaine est initialement partitionné et les interfaces sont gelées, permettant le remaillage indépendant de chaque sous-domaine. Une fois cette étape terminée, l’attention se porte sur les interfaces elles-mêmes : elles sont à leur tour partitionnées (en “gelant” les sous-interfaces nouvellement créées), puis remaillées. Ce processus de subdivision et de remaillage des interfaces peut être répété de manière récursive (gel des interfaces des interfaces, et ainsi de suite) jusqu’à atteindre un niveau de précision et de conformité satisfaisant sur l’ensemble des frontières.</p>
<center>
<img src="Contributions/../images/Freezing_Interface.png" alt="Logo Tucanos" width="80%">
</center>
<p>Au-delà des stratégies de gestio ndes interfaces pour le remaillage parallèle, la problématique fondamentale de la dibision initiale d’un maillage en sous-domaines demeure. Cette tâche est assurée par les algorithmes de partitionnement dont les objectifs ont été discutés plus tôt. Nous allons introduire ici une séléction des partitionneurs utilisés au sein de Tucanos, ainsi que ceux implémentés dans le cadre des travaux de thèse. On effectuera une analyse comparative de leurs performances sur un cas test :</p>
<h4 id="1-hilbert-ball-partitionner"><a class="header" href="#1-hilbert-ball-partitionner">1. Hilbert Ball Partitionner</a></h4>
<h4 id="2-bfs--bfs-with-restart-bfswr"><a class="header" href="#2-bfs--bfs-with-restart-bfswr">2. BFS &amp; BFS With Restart (BFSWR)</a></h4>
<h4 id="3-metis-partitionner"><a class="header" href="#3-metis-partitionner">3. Metis Partitionner</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load-balancing"><a class="header" href="#load-balancing">Load Balancing</a></h1>
<p>Une stratégie efficace de partitonnement devrait également faire en sorte d’équilibrer la charge de calcul entre les différents processeurs. Chaque travail de remaillage étant effectué indépendamment sur les différentes partitions, la performance globale d’une parallélisation de l’algorithme de remaillage sera limitée par la partition ayant la plus grosse charge computationnelle.</p>
<p>Cette charge de travail dépend des opérations de remaillage utilisées (insertion, collapse, swap, smoothing), de la métrique cible \(\mathcal{M}(x)_{x \in \Omega}\), du maillage initial \(\mathcal{H}\) et de sa métrique induite \( (\mathcal{M} _{\mathcal{H}}(x)) _{x \in \Omega} \) avec \(\Omega\) le domaine à remailler.</p>
<h4 id="remarque-"><a class="header" href="#remarque-">Remarque :</a></h4>
<p>En effet, si l’on considère que la métrique induite par le maillage initiale est égale en tout point du domaine \(\Omega\) à la métrique cible, i.e \( (\mathcal{M} _{\mathcal{H}}(x)) _{x \in \Omega} = \mathcal{M}_T(x) _{x \in \Omega}\) alors aucun travail de remaillage sera à effectuer.</p>
<p>Pour pouvoir définir le travail global de remaillage à effectuer, on procède à une estimation du travail élément par élément. On utilise toutefois une approche continue puisqu’on le rapelle les différents champs de métrique sont définis en tout point du domaine \(\Omega\).</p>
<h4 id="définition--densité--compléxité"><a class="header" href="#définition--densité--compléxité">Définition : Densité &amp; Compléxité</a></h4>
<p>Pour une métrique donnée  \(\mathcal{M}(x)_{x \in \Omega}\), la densité en chaque point du domaine \(\Omega\) est déterminée par :</p>
<p>\[ d_{\mathcal{M}}(x) = \sqrt{ det\mathcal{M}(x)}  \]</p>
<p>La densité ponctuelle \( d_{\mathcal{M}}(x)\) influence directement le nombre d’éléments requis dans le maillage adapté : une densité plus élévée dans des régions spécifique du maillage entrainera un plus grand nombre d’élement dans ces zones. La compléxité d’un maillage \( \mathcal{N} \), définie comme le dual du nombre total de sommets N dans le maillage, est uen conséquence directe de la distribution de la densité de la métrique sur \(\Omega\).</p>
<p>\[ \mathcal{N} =  \int_{x \in \Omega}^{} \sqrt{det \mathcal{M}(x) } \ dx = \int_{x \in \Omega}^{} d_{ \mathcal{M}}(x) \ dx \]</p>
<p>On se propose de définir le travail de remaillage à effectuer par élément, le travail total sur le maillage étant la somme du travail à réaliser sur chaque élément.
Chaque élément \(K\) du maillage initial \(\mathcal{H} \) possède sa propre métrique induite \( \mathcal{M}_ {\mathcal{H}}\) réduite à l’élément K ainsi qu’une métrique cible également réduite à l’élément \(K\). Pour chacune des métriques, la métrique réduite à l’élément \(K\) est obtenue en effectuant la moyenne de ses métriques à chacun de ses sommets :</p>
<p>\[ \mathcal{M}|_ K = exp( \ \sum_{i=1}^{n} \ \frac{1}{n} \ ln( \ \mathcal{M}(x_i) \ ) \ )   \text{  where  } x_i \text{ are the vertices of } K \]</p>
<p>On peut également calculer l’intersection de la métrique cible et de la métrique induite :  \[ \mathcal{M}_ { \cap }|_ K= \mathcal{M}_ {\mathcal{H}}|_ K \cap \mathcal{M}_ T |_ K\]
On dénotera alors \( d_{T} , d_{\mathcal{H}}, d_{\cap} \)  les densités des métriques \( \mathcal{M}_ T|_ K, \mathcal{M} _{\mathcal{H}} | _ K \) et  \( \mathcal{M} _ { \cap } | _ K \) respectivement.
On analysera le travail dans deux configurations spécifiques et on généralisera à toutes configurations.</p>
<h3 id="cas-dinsertion-"><a class="header" href="#cas-dinsertion-">Cas d’insertion :</a></h3>
<center>
<img src="Contributions/../images/Insertion.png" alt="Logo Tucanos" width="25%">
</center>
<p>Prennons le cas, ou le maillage sera uniquement raffiné, la densité de points à insérer est \( d_{\mathcal{M}_T \setminus  \mathcal{M} _{\mathcal{H}} }\) d’où le travail à effectuer par élément est défini par :</p>
<p>\[ wrk(K) = \alpha |K|(d_{ T} - d_{\mathcal{H}})  = \alpha |K|(d_{\cap} - d_{\mathcal{H}}) \]</p>
<p>Avec :</p>
<ul>
<li>\(\alpha\), le coût de l’opérateur d’insertion</li>
<li>\(|K|\), le volume de l’élément</li>
<li>\( \mathcal{M} _ { \cap } =  \mathcal{M} _ T \) dans ce cas précis</li>
</ul>
<p>Il est important de garder en tête ici que la densité est inversement proportionnelle à la “taille” de l’ellipse représentant la métrique.</p>
<h3 id="cas-de-collapse-"><a class="header" href="#cas-de-collapse-">Cas de Collapse :</a></h3>
<center>
<img src="Contributions/../images/Collapse.png" alt="Logo Tucanos" width="23%">
</center>
<p>Dans le cas où le maillage est uniquement dégrossi, la densité des points à insérer devient : \( d_{\mathcal{M} _{\mathcal{H}} \setminus \mathcal{M}_T   }\)</p>
<p>\[ wrk(K) = \beta |K|(d_{\mathcal{H}} - d_{ T})  = \beta |K|(d_{\cap} - d_{ T}) \]</p>
<p>Avec :</p>
<ul>
<li>\(\beta\) le coût de l’opérateur d’insertion</li>
<li>\(|K|\) le volume de l’élément</li>
<li>\( \mathcal{M} _ { \cap } =  \mathcal{M} _ {\mathcal{H}} \) dans ce cas précis</li>
</ul>
<h3 id="cas-general-"><a class="header" href="#cas-general-">Cas General :</a></h3>
<center>
<img src="Contributions/../images/Cas_general_bg.png" alt="Logo Tucanos" width="90%">
</center>
<p>#Ajouter discussion operateur opti</p>
<p>Dans le cas général, il est possible d’avoir à insérer et à supprimmer localement des éléments de maillage pour l’adapatation d’un seul et même élément. En effet, cette situation survient, par exemple, lorsque deux métriques possèdent la même densité mais des axes orientés dans des directions différentes.</p>
<p>Une telle configuration impliquant un raffinement dans une direction et un dégrossissement dans une autre. Le cas général englobe toutes les situations et la métrique d’intersection sert de base commune pour l’adapatation. La charge de travail est donc déterminée par la formule suivante :</p>
<p>\[ wrk(K)   = |K| \ ( \alpha  \ (d_{\cap} - d_{\mathcal{H}})  +  \beta  \ (d_{\cap} - d_{ T}) \ ) \]</p>
<h2 id="premiers-résultats-et-observations"><a class="header" href="#premiers-résultats-et-observations">Premiers Résultats et Observations</a></h2>
<p>Après l’implémentation initiale des concepts de partitionnement et d’estimation de charge, les premiers cas tests ont permis de dégager des observations cruciales concernant le comportement des algorithmes et la nature des défis liés à l’adaptation de maillage parallèle. Nous présentons ici les conclusions préliminaires tirées de ces expérimentations.</p>
<p>Les expérimentations ont été menées sur une série de configuration en deux et trois dimensions.</p>
<h4 id="ressources-de-calcul-"><a class="header" href="#ressources-de-calcul-">Ressources de Calcul :</a></h4>
<pre><code>hyperlink to environnement de travail ? 
</code></pre>
<h4 id="configuration-2d-"><a class="header" href="#configuration-2d-">Configuration 2D :</a></h4>
<ul>
<li>
<p>\( \Omega = [0,1]\times[0,1]\)</p>
</li>
<li>
<p>\(\mathcal{M}_T =<br />
\begin{bmatrix}0.01&amp;0 \\
0 &amp; 0.01\end{bmatrix} \) si \( (x,y) \in \mathcal{C}(o= (0.3,0.3), r=0.1) \)</p>
</li>
<li>
<p>\( \mathcal{M}_T  = \mathcal{M} _{\mathcal{H}}\) <strong>sinon</strong></p>
</li>
<li>
<p>Partitionneurs : <strong>Hilbert, BFS , BFSWR</strong></p>
</li>
</ul>
<h4 id="configuration-3d"><a class="header" href="#configuration-3d">Configuration 3D:</a></h4>
<ul>
<li>
<p>\( \Omega = [0,1]^3\)</p>
</li>
<li>
<p>\(\mathcal{M}_T =<br />
\begin{bmatrix}0.01&amp;0&amp;0\\
0 &amp; 0.01 &amp; 0\\
0 &amp; 0 &amp; 0.01\end{bmatrix} \) si \( (x,y,z) \in \mathcal{C}(o= (0.3,0.3,0.3), r=0.1) \)</p>
</li>
<li>
<p>\( \mathcal{M}_T  = \mathcal{M} _{\mathcal{H}}\) <strong>sinon</strong></p>
</li>
<li>
<p>Partitionneurs : <strong>Hilbert, BFS , BFSWR</strong></p>
</li>
<li>
<p>Nombre de partionneurs = 4</p>
</li>
</ul>
<h3 id="1-coûts-uniforme"><a class="header" href="#1-coûts-uniforme">1. Coûts Uniforme</a></h3>
<p>Les premières évaluations, où les coûts des opérateurs d’insertion \(\alpha \), de dégrossissement \(\beta \) et d’optimisation \( \gamma \) ont été fixés à 1, ont mis en lumière plusieurs tendances :</p>
<ul>
<li>
<h4 id="déséquilibre-de-charge-par-nombre-de-sommets-"><a class="header" href="#déséquilibre-de-charge-par-nombre-de-sommets-">Déséquilibre de charge par nombre de sommets :</a></h4>
L’algorithme de partitionnement, tel qu’il est actuellement implémenté, génère des partitions déséquilibrées en termes de charge computationnelle effective.En effet, les zones identifiées comme nécessitant un travail de remaillage intense concentrent un nombre réduit de sommets par partition, mais un volume d’opérations élevé. Inversement, les partitions situées en dehors de ces zones à forte activité se retrouvent avec un nombre de sommets plus important, mais un travail de remaillage proportionnellement plus faible. Ce déséquilibre entraîne une conséquence majeure : les temps de vérification de faisabilité des opérations de remaillage sur les partitions à fort nombre de sommets deviennent supérieurs aux temps de réalisation des opérations de remaillage sur les partitions à faible nombre de sommets, créant ainsi des goulots d’étranglement.</li>
<li>
<h4 id="propagation-des-opérations-de-remaillage-"><a class="header" href="#propagation-des-opérations-de-remaillage-">Propagation des opérations de remaillage :</a></h4>
Nous avons également découvert qu’une métrique spécifiquement calibrée pour induire uniquement des opérations de pur raffinement (split) engendraient de nouvelles opérations de remaillage par la suite. En effet les splits effectués créent de nouveaux éléments, qui ne respectant pas forcément les conditions de qualité minimum et par conséquent qui engendrent des opérations d’adaptation additionnelles.</li>
</ul>
<p>Ces premières observations mettent en évidence la nécessité de modifier l’algorithme d’estimation de la charge de travail de telle manière à ce qu’il prenne en compte le coût d’une opération mais également le coût induit par une telle opération ainsi que la quantité d’élément finale dans chaque partition.
\(\)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-and-references"><a class="header" href="#appendix-and-references">Appendix and References</a></h1>
<p>To further support the understanding of this research, this section provides essential complementary information and a comprehensive list of references that have been instrumental to our work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<ul>
<li>
<p>George, P. L., Borouchaki, H., Alauzet, F., Laug, P., Loseille, A., &amp; Maréchal, L. (2018). <strong>Maillage, modélisation géométrique et simulation numérique Volume 2</strong>.
<br></p>
</li>
<li>
<p>Loseille, A., &amp; Alauzet, F. (2011). <strong>Continuous Mesh Framework Part I: Well-Posed Continuous Interpolation Error</strong>. <em>SIAM Journal on Numerical Analysis</em>, 49(1), 38-60.
<br></p>
</li>
<li>
<p>Loseille, A., &amp; Alauzet, F. (2011). <strong>Continuous Mesh Framework Part II: Validations and Applications</strong>. <em>SIAM Journal on Numerical Analysis</em>, 49(1), 61-86.
<br></p>
</li>
<li>
<p>Caplan, P. C. (2019). <strong>Four-Dimensional Anisotropic Mesh Adaptation for Spacetime Numerical Simulations</strong>.
<br></p>
</li>
<li>
<p>Loseille, A., Alauzet, F., &amp; Menier, V. (2017). <strong>Unique cavity-based operator and hierarchical domain partitioning for fast parallel generation of anisotropic meshes</strong>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
